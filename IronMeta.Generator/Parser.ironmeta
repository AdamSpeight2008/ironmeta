//////////////////////////////////////////////////////////////////////
// $Id$
//
// Copyright (C) 2009-2011, The IronMeta Project
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions 
// are met:
// 
//     * Redistributions of source code must retain the above 
//       copyright notice, this list of conditions and the following 
//       disclaimer.
//     * Redistributions in binary form must reproduce the above 
//       copyright notice, this list of conditions and the following 
//       disclaimer in the documentation and/or other materials 
//       provided with the distribution.
//     * Neither the name of the IronMeta Project nor the names of its 
//       contributors may be used to endorse or promote products 
//       derived from this software without specific prior written 
//       permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND  ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS 
// FOR  A  PARTICULAR  PURPOSE  ARE DISCLAIMED. IN  NO EVENT SHALL THE 
// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
// BUT NOT  LIMITED TO, PROCUREMENT  OF SUBSTITUTE  GOODS  OR SERVICES; 
// LOSS OF USE, DATA, OR  PROFITS; OR  BUSINESS  INTERRUPTION) HOWEVER 
// CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT 
// LIABILITY, OR  TORT (INCLUDING NEGLIGENCE  OR OTHERWISE) ARISING IN 
// ANY WAY OUT  OF THE  USE OF THIS SOFTWARE, EVEN  IF ADVISED  OF THE 
// POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////

using IronMeta.Generator;
using IronMeta.Generator.AST;

ironmeta Parser<char, ASTNode<_Parser_Item>> : IronMeta.Matcher.CharMatcher<ASTNode<_Parser_Item>>
{

    IronMetaFile = '\ufeff'? SP Preamble?:p Grammar:g EOF -> { return new GrammarFile<_Parser_Item>(p, g); };

    Preamble = Using+:u -> { return new Preamble<_Parser_Item>(u.Results); };

    Using = USING (Ident (DOT Ident)*):name SP SEMI -> { return new Using<_Parser_Item>(name); };

    Grammar = IRONMETA Identifier:name 
            LESS GenericId:tinput COMMA GenericId:tresult GREATER
            COLON GenericId:baseclass
            BRA Rule*:rules KET
        -> { return new Grammar<_Parser_Item>(name, tinput, tresult, baseclass, rules.Results); };

    Rule = OVERRIDE?:ovr Identifier:name Disjunction?:parms EQUALS Disjunction:body SEMI
        -> { return new Rule<_Parser_Item>(name, parms.Inputs.Any() ? new Args<_Parser_Item>(parms, body) : (AST.ASTNode<_Parser_Item>)body, ovr.Inputs.Any()); };

    Disjunction = ActionExp ( OR ActionExp )*
        ->  {
                return _IM_Result.Results
                    .Where(node => node != null)
                    .Aggregate<ASTNode<_Parser_Item>, ASTNode<_Parser_Item>>(null, (prev, cur) => prev != null ? new Or<_Parser_Item>(prev, cur) : cur);
            };

    ActionExp = SequenceExp:body ACTION &BRA CSharpCode:action -> { return new Act<_Parser_Item>(body, action); };
    ActionExp = SequenceExp;

    FailExp = BANG (CSharpCode:msg)? -> { return new Fail<_Parser_Item>(msg); };

    SequenceExp = ConditionExp+
        ->  {
                return _IM_Result.Results
                    .Where(node => node != null)
                    .Aggregate<ASTNode<_Parser_Item>, ASTNode<_Parser_Item>>(null, (prev, cur) => prev != null ? new And<_Parser_Item>(prev, cur) : cur);
            };

    ConditionExp = FailExp;
    ConditionExp = BoundTerm:body QUES &OPEN CSharpCode:cond -> { return new Cond<_Parser_Item>(body, cond); };
    ConditionExp = BoundTerm;

    BoundTerm = PrefixedTerm:exp COLON Identifier:id -> { return new Bind<_Parser_Item>(exp, id); };
    BoundTerm = COLON Identifier:id -> { return new Bind<_Parser_Item>(new Any<_Parser_Item>(), id); };
    BoundTerm = PrefixedTerm;

    PrefixedTerm = LookTerm | NotTerm | PostfixedTerm;
    LookTerm = AND_PRE PostfixedTerm:exp -> { return new Look<_Parser_Item>(exp); };
    NotTerm = NOT_PRE PostfixedTerm:exp -> { return new Not<_Parser_Item>(exp); };

    PostfixedTerm = StarTerm | PlusTerm | QuesTerm | Term;

    StarTerm = Term:exp STAR -> { return new Star<_Parser_Item>(exp); };
    PlusTerm = Term:exp PLUS -> { return new Plus<_Parser_Item>(exp); };
    QuesTerm = Term:exp QUES ~OPEN SP -> { return new Ques<_Parser_Item>(exp); };

    Term = InputClass | ParenTerm | RuleCall | CallOrVar | Literal | AnyTerm;

    ParenTerm = OPEN Disjunction:exp CLOSE -> { return exp; };
    AnyTerm = PERIOD -> { return new Any<_Parser_Item>(); };

    RuleCall = Ident:name OPEN ParameterList?:p CLOSE -> { return new Call<_Parser_Item>(name, p.Results); };
    ParameterList = Parameter (COMMA Parameter)* -> { return _IM_Result.Results.Where(node => node != null); };
    Parameter = CallOrVar | Literal;

    CallOrVar = Identifier:id -> { return new CallOrVar<_Parser_Item>(id); };
    Literal = &('\x22' | '\x27' | '{') CSharpCode:code -> { return code; };

    InputClass = '[' SP (ClassRange | &'\x27' Literal)+:c ']' SP -> { return new InputClass<_Parser_Item>(c.Results); };
    ClassRange = &'\x27' Literal:from SP '-' SP &'\x27' Literal:to SP ->
        {
            char ch_from = AST.ClassRange<_Parser_Item>.GetChar(from);
            char ch_to = AST.ClassRange<_Parser_Item>.GetChar(to);

            List<char> range = new List<char>();
            if (ch_from > ch_to)			    
            {
                range.Add(ch_from);
                range.Add(ch_to);
            }
            else
            {
                for (char ch = ch_from ; ch <= ch_to; ++ch)
                    range.Add(ch);
            }

            return new ClassRange<_Parser_Item>(_IM_Result, range);
        };

    CSharpCode = CSharpCodeItem:code SP -> { return new Code<_Parser_Item>(code); };

    CSharpCodeItem = '{' (~'}' (Comment | CSharpCodeItem | .))* '}';
    CSharpCodeItem = '(' (~')' (Comment | CSharpCodeItem | .))* ')';
    CSharpCodeItem = '\x27' ("\x5c\x27" | "\x5c\x5c" | ~'\x27' .)* '\x27';   // '
    CSharpCodeItem = '\x22' ("\x5c\x22" | "\x5c\x5c" | ~'\x22' .)* '\x22';   // "
    
    Identifier = Ident:id SP -> { return id; };
    Ident = (IdentBegin IdentBody*):id -> { return new Idfr<_Parser_Item>(id); };
    IdentBegin = '_' | . ?(System.Char.IsLetter(_IM_Result));
    IdentBody = '_' | . ?(System.Char.IsLetterOrDigit(_IM_Result));

    GenericId = (Ident (DOT Ident)*):ids SP (LESS (GenericId (COMMA GenericId)*) GREATER)?:gp
        -> { return new Idfr<_Parser_Item>(ids, gp); };

    USING = "using" SP;
    IRONMETA = "ironmeta" SP;
    EQUALS = ('=' | "::=") SP;
    OVERRIDE = "override" SP;
    LR = "lr" SP;
    SEMI = (';' | ',') SP;
    BANG = '!' SP;
    OR = '|' SP;
    ACTION = "->" SP;
    COLON = ':' SP;
    COMMA = ',' SP;
    DOT = '.';
    PERIOD = DOT SP;
    BRA = '{' SP;
    KET = '}' SP;
    OPEN = '(' SP;
    CLOSE = ')' SP;
    LESS = '<' SP;
    GREATER = '>' SP;
    QUES = '?'; // note no spacing
    AND_PRE = '&';
    NOT_PRE = '~';
    STAR = '*' SP;
    PLUS = '+' SP;
    
    EOL = '\r' '\n'? | '\n';
    EOF = ~.;

    SP = (WS | Comment)*;
    WS = ' ' | '\n' | '\r' | '\t';
    
    Comment = "//" (~('\r' '\n'? | '\n') .)* ('\r' '\n'? | '\n');
    Comment = "/*" (~"*/" .)* "*/";

}
