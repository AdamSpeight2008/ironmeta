//////////////////////////////////////////////////////////////////////
// $Id$
//
// Copyright (c) 2009, The IronMeta Project
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions 
// are met:
// 
//     * Redistributions of source code must retain the above 
//       copyright notice, this list of conditions and the following 
//       disclaimer.
//     * Redistributions in binary form must reproduce the above 
//       copyright notice, this list of conditions and the following 
//       disclaimer in the documentation and/or other materials 
//       provided with the distribution.
//     * Neither the name of the IronMeta Project nor the names of its 
//       contributors may be used to endorse or promote products 
//       derived from this software without specific prior written 
//       permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND  ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS 
// FOR  A  PARTICULAR  PURPOSE  ARE DISCLAIMED. IN  NO EVENT SHALL THE 
// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
// BUT NOT  LIMITED TO, PROCUREMENT  OF SUBSTITUTE  GOODS  OR SERVICES; 
// LOSS OF USE, DATA, OR  PROFITS; OR  BUSINESS  INTERRUPTION) HOWEVER 
// CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT 
// LIABILITY, OR  TORT (INCLUDING NEGLIGENCE  OR OTHERWISE) ARISING IN 
// ANY WAY OUT  OF THE  USE OF THIS SOFTWARE, EVEN  IF ADVISED  OF THE 
// POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////

ironMeta IronMeta<char, IronMeta.SyntaxNode> : IronMeta.CharacterMatcher<IronMeta.SyntaxNode>
{

    IronMetaFile = SP FilePreamble?:pre IronMetaParser*:parsers EOF
                -> { return new IronMetaFileNode(_IM_StartIndex, _IM_NextIndex, pre, parsers); };

    FilePreamble = ( UsingStatement )+;
    
    UsingStatement = "using" SP QualifiedIdentifier:id SP ("," | ";") SP
                -> { return new UsingStatementNode(_IM_StartIndex, _IM_NextIndex, id); };
    
    IronMetaParser = "ironMeta" SP ParserDeclaration:decl ParserBody:body
                -> { return new ParserNode(_IM_StartIndex, _IM_NextIndex, decl, body); };
    
    ParserDeclaration = GenericIdentifier:name SP BaseClassDeclaration?:bc
                -> { return new ParserDeclarationNode(_IM_StartIndex, _IM_NextIndex, name, bc); };
    
    BaseClassDeclaration = ":" SP GenericIdentifier:id SP
                -> { return id; };
    
    
    
    ParserBody = "{" SP Rule*:rules "}" SP
                -> { return new ParserBodyNode(_IM_StartIndex, _IM_NextIndex, rules); };
    
    Rule = ("override" SP)?:ovr Identifier:name SP Disjunction?:parms ("::=" | "=") SP Disjunction:body ("," | ";") SP
                -> {
                        bool isOverride = ovr.Results.Any();
                        SyntaxNode pNode = parms.Results.Any() ? (SyntaxNode)parms : null;
                        return new RuleNode(_IM_StartIndex, _IM_NextIndex, isOverride, name, pNode, body);
                    };
    
    Disjunction = ActionExpression ("|" SP ActionExpression)*
                    -> { return new DisjunctionExpNode(_IM_StartIndex, _IM_NextIndex, _IM_Result.Results.Where(n => n is ExpNode)); };
        
    ActionExpression = SequenceExpression:exp ("=>" | "->") SP &'{' CSharpCode:action SP
                    -> { return new ActionExpNode(_IM_StartIndex, _IM_NextIndex, exp, action); }
                | SequenceExpression
                | FailExpression;
        
    FailExpression = "!" (&'\"' CSharpCode:str)? SP
                    -> { return new FailExpNode(_IM_StartIndex, _IM_NextIndex, str); };

    SequenceExpression = ConditionExpression+
                    -> { return new SequenceExpNode(_IM_StartIndex, _IM_NextIndex, _IM_Result.Results); };
    
    ConditionExpression = BoundTerm:exp ('?' &'(') CSharpCode:cond SP
                    -> { return new ConditionExpNode(_IM_StartIndex, _IM_NextIndex, exp, cond); }
                | BoundTerm;
    
    BoundTerm = PrefixedTerm:exp ":" Identifier:id SP
                    -> { return new BoundExpNode(_IM_StartIndex, _IM_NextIndex, exp, id); }
              | ":" Identifier:id SP
                    -> { return new BoundExpNode(_IM_StartIndex, _IM_NextIndex, new AnyExpNode(_IM_StartIndex, _IM_NextIndex), id); }
              | PrefixedTerm:exp SP
                    -> { return exp; };
    
    
    PrefixedTerm = AndTerm | NotTerm | PostfixedTerm;
    
    AndTerm = "&" PostfixedTerm:exp
            -> { return new UnaryExpNode(_IM_StartIndex, _IM_NextIndex, exp, "LOOK"); };
    
    NotTerm = "~" PrefixedTerm:exp
            -> { return new UnaryExpNode(_IM_StartIndex, _IM_NextIndex, exp, "NOT"); };
    
    
    PostfixedTerm = StarTerm | PlusTerm | QuestionTerm | Term | !"expected a pattern term";
    
    StarTerm = PostfixedTerm:exp "*"
            -> { return new UnaryExpNode(_IM_StartIndex, _IM_NextIndex, exp, "STAR"); };
    
    PlusTerm = PostfixedTerm:exp "+"
            -> { return new UnaryExpNode(_IM_StartIndex, _IM_NextIndex, exp, "PLUS"); };
    
    QuestionTerm = PostfixedTerm:exp ('?' ~'(')
            -> { return new UnaryExpNode(_IM_StartIndex, _IM_NextIndex, exp, "QUES"); }; 
    
    
    Term = ParenTerm | BracketTerm | AnyTerm | RuleCall | CallOrVar | Literal;
    
    ParenTerm = "(" SP Disjunction:exp ")"
            -> { return exp; };

    BracketTerm = "[" SP ((LiteralRange | Literal) SP)+:exp "]"
            -> { return new BracketExpNode(_IM_StartIndex, _IM_NextIndex, exp.Results.Where(n => n is LiteralExpNode || n is LiteralRangeNode)); };

    LiteralRange = Literal SP ".." SP Literal
            -> { return new LiteralRangeNode(_IM_StartIndex, _IM_NextIndex, _IM_Result.Results.Where(n => n is LiteralExpNode)); };
    
    AnyTerm = "."
            -> { return new AnyExpNode(_IM_StartIndex, _IM_NextIndex); };
    
    RuleCall = QualifiedIdentifier:name "(" SP ParameterList?:p ")"
            -> { return new RuleCallExpNode(_IM_StartIndex, _IM_NextIndex, name, p); };
    
    ParameterList = Parameter ("," SP Parameter)*
            -> { return _IM_Result.Results.Where(n => n is ExpNode); };
            
    Parameter = (CallOrVar | Literal):p SP
            -> { return p; };
            
    CallOrVar = QualifiedIdentifier
            -> { return new CallOrVarExpNode(_IM_StartIndex, _IM_NextIndex, _IM_Result); };

    Literal = &['\"' '\'' '{'] CSharpCode
            -> { return new LiteralExpNode(_IM_StartIndex, _IM_NextIndex, _IM_Result.Results); };

    
    CSharpCode = CSharpCodeItem
            -> { return new CSharpNode(_IM_StartIndex, _IM_NextIndex); };

    CSharpCodeItem = '{' ((~'}') (CSharpCodeItem | Comment | EOL | .))* '}'
                   | '(' ((~')') (CSharpCodeItem | Comment | EOL | .))* ')'
                   | '\"' ( ("\x5c\x5c") | ("\x5c\"") | ((~'\"') (EOL | .)) )* '\"'
                   | '\'' ( ("\x5c\x5c") | ("\x5c\'") | ((~'\'') (EOL | .)) )* '\'';


    GenericIdentifier = QualifiedIdentifier:id ("<" SP (GenericIdentifier SP ("," SP GenericIdentifier SP)*):p ">")?
            -> {
                    var idn = (IdentifierNode) id;
                    return new IdentifierNode(_IM_StartIndex, _IM_NextIndex, idn, idn.Qualifiers, p.Results.Where(n => n is IdentifierNode));
                };

    QualifiedIdentifier = (Identifier ".")*:quals Identifier:name
            -> { return new IdentifierNode(_IM_StartIndex, _IM_NextIndex, name, quals.Results.Where(n => n is IdentifierNode), null); };
    
    //Identifier = IdentBegin IdentChar*

    Identifier = [ '_' 'a' .. 'z' 'A' .. 'Z' ] [ '_' 'a' .. 'z' 'A' .. 'Z' '0' .. '9' ]*
            -> { return new IdentifierNode(_IM_StartIndex, _IM_NextIndex, null, null, null); };
            
    IdentBegin = ('_' | . ?(System.Char.IsLetter(_IM_Result)));
    
    IdentChar = ('_' | . ?(System.Char.IsLetterOrDigit(_IM_Result)));

    SP = (Comment | Whitespace)* -> { return new SpacingNode(_IM_StartIndex, _IM_NextIndex, _IM_Result.Results); };
    
    Comment = (  "//" EOLCommentChar* (EOL|EOF)  |  "/*" BracketCommentChar* "*/" )
            -> { return new CommentNode(_IM_StartIndex, _IM_NextIndex); };
    
    EOLCommentChar = ~EOL .;
    BracketCommentChar = (~("*/") (EOL | .));
        
    override Whitespace = EOL | . ?(System.Char.IsWhiteSpace(_IM_Result)) 
                                -> { return new TokenNode(_IM_StartIndex, _IM_NextIndex, TokenNode.TokenType.WHITESPACE); };

    override EOL = ("\x0d\x0a" | '\x0a' | '\x0d' ~'\x0a' | '\x0085' | '\x000c' | '\x2028' | '\x2029')
            -> { _IM_LineBeginPositions.Add(_IM_NextIndex); return new TokenNode(_IM_StartIndex, _IM_NextIndex, TokenNode.TokenType.EOL); };
    
    override EOF = ~. 
            -> { _IM_LineBeginPositions.Add(_IM_StartIndex); return new TokenNode(_IM_StartIndex, _IM_NextIndex, TokenNode.TokenType.EOF); };

    override EOF = !"unexpected end of file";    

}
