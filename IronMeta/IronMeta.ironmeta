//////////////////////////////////////////////////////////////////////
// $Id$
//
// Copyright (c) 2009, The IronMeta Project
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions 
// are met:
// 
//     * Redistributions of source code must retain the above 
//       copyright notice, this list of conditions and the following 
//       disclaimer.
//     * Redistributions in binary form must reproduce the above 
//       copyright notice, this list of conditions and the following 
//       disclaimer in the documentation and/or other materials 
//       provided with the distribution.
//     * Neither the name of the IronMeta Project nor the names of its 
//       contributors may be used to endorse or promote products 
//       derived from this software without specific prior written 
//       permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND  ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS 
// FOR  A  PARTICULAR  PURPOSE  ARE DISCLAIMED. IN  NO EVENT SHALL THE 
// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
// BUT NOT  LIMITED TO, PROCUREMENT  OF SUBSTITUTE  GOODS  OR SERVICES; 
// LOSS OF USE, DATA, OR  PROFITS; OR  BUSINESS  INTERRUPTION) HOWEVER 
// CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT 
// LIABILITY, OR  TORT (INCLUDING NEGLIGENCE  OR OTHERWISE) ARISING IN 
// ANY WAY OUT  OF THE  USE OF THIS SOFTWARE, EVEN  IF ADVISED  OF THE 
// POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////

ironMeta IronMeta<char, IronMeta.SyntaxNode> : IronMeta.CharacterMatcher<IronMeta.SyntaxNode>
{

    IronMetaFile = SP FilePreamble?:pre IronMetaParser*:parsers EOF
                -> { return new IronMetaFileNode(_IM_StartIndex, _IM_NextIndex, pre, parsers); };

    FilePreamble = ( UsingStatement )+;
    
    UsingStatement = "using" SP QualifiedIdentifier:id SP ("," | ";") SP
                -> { return new UsingStatementNode(_IM_StartIndex, _IM_NextIndex, id); };
    
    IronMetaParser = "ironMeta" SP ParserDeclaration:decl ParserBody:body
                -> { return new ParserNode(_IM_StartIndex, _IM_NextIndex, decl, body); };
    
    ParserDeclaration = GenericIdentifier:name SP BaseClassDeclaration?:bc
                -> { return new ParserDeclarationNode(_IM_StartIndex, _IM_NextIndex, name, bc); };
    
    BaseClassDeclaration = ":" SP GenericIdentifier:id SP
                -> { return id; };
    
    
    
    ParserBody = "{" SP Rule*:rules "}" SP
                -> { return new ParserBodyNode(_IM_StartIndex, _IM_NextIndex, rules); };
    
    Rule = ("override" SP)?:ovr Identifier:name SP Disjunction?:parms ("::=" | "=") SP Disjunction:body ("," | ";") SP
                -> {
                        bool isOverride = ovr.Results.Any();
                        SyntaxNode pNode = parms.Results.Any() ? (SyntaxNode)parms : null;
                        return new RuleNode(_IM_StartIndex, _IM_NextIndex, isOverride, name, pNode, body);
                    };
    
    Disjunction = ActionExpression ("|" SP ActionExpression)*
					-> { return new DisjunctionExpNode(_IM_StartIndex, _IM_NextIndex, _IM_Result.Results.Where(node => node is ExpNode)); };
        
    ActionExpression = SequenceExpression:exp ("->" | "=>") SP &'{' CSharpCode:action SP
                    -> { return new ActionExpNode(_IM_StartIndex, _IM_NextIndex, exp, action); }
                | SequenceExpression
                | FailExpression;
        
    FailExpression = "!" (&'\"' CSharpCode:str)? SP
                    -> { return new FailExpNode(_IM_StartIndex, _IM_NextIndex, str); };

	SequenceExpression = ConditionExpression+
					-> { return new SequenceExpNode(_IM_StartIndex, _IM_NextIndex, _IM_Result.Results.Where(node => node is ExpNode)); };
    
    ConditionExpression = BoundTerm:exp ('?' &'(') CSharpCode:cond SP
                    -> { return new ConditionExpNode(_IM_StartIndex, _IM_NextIndex, exp, cond); }
                | BoundTerm;
    
    BoundTerm = PrefixedTerm:exp ":" Identifier:id SP
                    -> { return new BoundExpNode(_IM_StartIndex, _IM_NextIndex, exp, id); }
              | ":" Identifier:id SP
                    -> { return new BoundExpNode(_IM_StartIndex, _IM_NextIndex, new AnyExpNode(_IM_StartIndex, _IM_NextIndex), id); }
              | PrefixedTerm:exp SP
					-> { return exp; };
    
    
    PrefixedTerm = AndTerm | NotTerm | PostfixedTerm;
    
    AndTerm = "&" PostfixedTerm:exp
            -> { return new PrefixedExpNode(_IM_StartIndex, _IM_NextIndex, exp, "LOOK"); };
    
    NotTerm = "~" PrefixedTerm:exp
            -> { return new PrefixedExpNode(_IM_StartIndex, _IM_NextIndex, exp, "NOT"); };
    
    
    PostfixedTerm = StarTerm | PlusTerm | QuestionTerm | Term;
    
    StarTerm = PostfixedTerm:exp "*"
            -> { return new PostfixedExpNode(_IM_StartIndex, _IM_NextIndex, exp, "STAR"); };
    
    PlusTerm = PostfixedTerm:exp "+"
            -> { return new PostfixedExpNode(_IM_StartIndex, _IM_NextIndex, exp, "PLUS"); };
    
    QuestionTerm = PostfixedTerm:exp ('?' ~'(')
            -> { return new PostfixedExpNode(_IM_StartIndex, _IM_NextIndex, exp, "QUES"); }; 
    
    
    Term = ParenTerm | AnyTerm | RuleCall | CallOrVar | Literal;
    
    ParenTerm = "(" SP Disjunction:exp ")"
            -> { return exp; };
    
    AnyTerm = "."
            -> { return new AnyExpNode(_IM_StartIndex, _IM_NextIndex); };
    
    RuleCall = QualifiedIdentifier:name "(" SP ParameterList?:p ")"
            -> { return new RuleCallExpNode(_IM_StartIndex, _IM_NextIndex, name, p); };
    
    ParameterList = Parameter ("," SP Parameter)*
            -> { return _IM_Result.Results.Where(child => child is ExpNode); };
            
    Parameter = (CallOrVar | Literal):p SP
			-> { return p; };
            
    CallOrVar = QualifiedIdentifier
            -> { return new CallOrVarExpNode(_IM_StartIndex, _IM_NextIndex, _IM_Result); };

    Literal = &('\"' | '\'' | '{') CSharpCode
            -> { return new LiteralExpNode(_IM_StartIndex, _IM_NextIndex, _IM_Result.Results); };

    
    CSharpCode = CSharpCodeItem
            -> { return new CSharpNode(_IM_StartIndex, _IM_NextIndex); };

    CSharpCodeItem = '{' ((~'}') (CSharpCodeItem | Comment | EOL | .))* '}'
                   | '(' ((~')') (CSharpCodeItem | Comment | EOL | .))* ')'
                   | '\"' ( ('\x5c' '\x5c') | ('\x5c' '\"') | ((~'\"') (EOL | .)) )* '\"'
                   | '\'' ( ('\x5c' '\x5c') | ('\x5c' '\'') | ((~'\'') (EOL | .)) )* '\'';


    GenericIdentifier = QualifiedIdentifier:id ("<" SP (GenericIdentifier SP ("," SP GenericIdentifier SP)*):p ">")?
            -> {
					var idn = (IdentifierNode) id;
					return new IdentifierNode(_IM_StartIndex, _IM_NextIndex, idn, idn.Qualifiers, p.Results.Where(node => node is IdentifierNode));
                };

    QualifiedIdentifier = (Identifier ".")*:quals Identifier:name
            -> {
					return new IdentifierNode(_IM_StartIndex, _IM_NextIndex, name, quals.Results.Where(node => node is IdentifierNode), null);
                };
    
    Identifier = (. ?(_IM_Result == '_' || System.Char.IsLetter(_IM_Result))) 
                 (. ?(_IM_Result == '_' || System.Char.IsLetterOrDigit(_IM_Result)))*
            -> { return new IdentifierNode(_IM_StartIndex, _IM_NextIndex, null, null, null); };

    SP = (Comment | Whitespace)* -> { return new SpacingNode(_IM_StartIndex, _IM_NextIndex, _IM_Result.Results); };
    
    Comment = (  '/' '/' (~('\r'|'\n') .)* (EOL|EOF)
               | '/' '*' (~('*' '/') (EOL | .))* '*' '/' )
            -> { return new CommentNode(_IM_StartIndex, _IM_NextIndex); };
        
    override Whitespace = ('\r' '\n' | '\n' | '\r' ~'\n') 
            -> { _IM_LineBeginPositions.Add(_IM_NextIndex); return new TokenNode(_IM_StartIndex, _IM_NextIndex, TokenNode.TokenType.EOL); }
            
                        | . ?(System.Char.IsWhiteSpace(_IM_Result)) 
            -> { return new TokenNode(_IM_StartIndex, _IM_NextIndex, TokenNode.TokenType.WHITESPACE); };

    override EOL = ('\r' '\n' | '\n' | '\r' ~'\n') 
            -> { _IM_LineBeginPositions.Add(_IM_NextIndex); return new TokenNode(_IM_StartIndex, _IM_NextIndex, TokenNode.TokenType.EOL); };
    
    override EOF = ~. 
            -> { _IM_LineBeginPositions.Add(_IM_StartIndex); return new TokenNode(_IM_StartIndex, _IM_NextIndex, TokenNode.TokenType.EOF); };
    
}
