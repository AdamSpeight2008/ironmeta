//////////////////////////////////////////////////////////////////////
// Copyright (C) 2009-2012, The IronMeta Project
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions 
// are met:
// 
//     * Redistributions of source code must retain the above 
//       copyright notice, this list of conditions and the following 
//       disclaimer.
//     * Redistributions in binary form must reproduce the above 
//       copyright notice, this list of conditions and the following 
//       disclaimer in the documentation and/or other materials 
//       provided with the distribution.
//     * Neither the name of the IronMeta Project nor the names of its 
//       contributors may be used to endorse or promote products 
//       derived from this software without specific prior written 
//       permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND  ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS 
// FOR  A  PARTICULAR  PURPOSE  ARE DISCLAIMED. IN  NO EVENT SHALL THE 
// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
// BUT NOT  LIMITED TO, PROCUREMENT  OF SUBSTITUTE  GOODS  OR SERVICES; 
// LOSS OF USE, DATA, OR  PROFITS; OR  BUSINESS  INTERRUPTION) HOWEVER 
// CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT 
// LIABILITY, OR  TORT (INCLUDING NEGLIGENCE  OR OTHERWISE) ARISING IN 
// ANY WAY OUT  OF THE  USE OF THIS SOFTWARE, EVEN  IF ADVISED  OF THE 
// POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////

using IronMeta.Generator;
using IronMeta.Generator.AST;

ironmeta Parser<char, ASTNode> : IronMeta.Matcher.CharMatcher<ASTNode>
{

    IronMetaFile = '\ufeff'? SP Preamble?:p Grammar:g EOF -> { return new GrammarFile(p, g); };

    Preamble = Using+:u -> { return new Preamble(u.Results); };

    Using = USING (Ident (DOT Ident)*):name SP SEMI -> { return new Using(name); };

    Grammar = IRONMETA Identifier:name 
            LESS GenericId:tinput COMMA GenericId:tresult GREATER
            COLON GenericId:baseclass
            BRA Rule*:rules KET
        -> { return new Grammar(name, tinput, tresult, baseclass, rules.Results); };

    Rule = OVERRIDE?:ovr Identifier:name Disjunction?:parms EQUALS Disjunction:body SEMI
        -> { return new Rule(name, parms.Inputs.Any() ? new Args(parms, body) : (AST.ASTNode)body, Trimmed(ovr)); };

    Disjunction = ActionExp ( OR ActionExp )*
        ->  {
                return _IM_Result.Results
                    .Where(node => node != null)
                    .Aggregate<ASTNode, ASTNode>(null, (prev, cur) => prev != null ? new Or(prev, cur) : cur);
            };

    ActionExp = SequenceExp:body ACTION &BRA CSharpCode:action -> { return new Act(body, action); };
    ActionExp = SequenceExp;

    FailExp = BANG (CSharpCode:msg)? -> { return new Fail(msg); };

    SequenceExp = ConditionExp+
        ->  {
                return _IM_Result.Results
                    .Where(node => node != null)
                    .Aggregate<ASTNode, ASTNode>(null, (prev, cur) => prev != null ? new And(prev, cur) : cur);
            };

    ConditionExp = FailExp;
    ConditionExp = BoundTerm:body QUES &OPEN CSharpCode:cond -> { return new Cond(body, cond); };
    ConditionExp = BoundTerm;

    BoundTerm = PrefixedTerm:exp COLON Identifier:id -> { return new Bind(exp, id); };
    BoundTerm = COLON Identifier:id -> { return new Bind(new Any(), id); };
    BoundTerm = PrefixedTerm;

    PrefixedTerm = LookTerm | NotTerm | PostfixedTerm;
    LookTerm = AND_PRE PostfixedTerm:exp -> { return new Look(exp); };
    NotTerm = NOT_PRE PostfixedTerm:exp -> { return new Not(exp); };

    PostfixedTerm = MinMaxTerm | StarTerm | PlusTerm | QuesTerm | Term;

	MinMaxTerm = Term:exp BRA Number:n (COMMA Number:x)? KET ->
	    {
			int min = int.Parse(Input(n));
			int max = x != null && x.Inputs.Any() ? int.Parse(Input(x)) : min;

			if (min < 0)
			    throw new MatcherException(n.StartIndex, "min must be >= 0");
			if (max < 1)
			    throw new MatcherException(x.StartIndex, "max must be > 1");
			if (max < min)
			    throw new MatcherException(n.NextIndex, "max cannot be less than min for a MinMaxTerm");

			ASTNode res = null;
			for (int i = 0; i < min; ++i)
			    res = res != null ? new And(res, exp) : (ASTNode)exp;
			for (int i = 0; i < (max-min); ++i)
			    res = res != null ? new And(res, new Ques(exp)) : (ASTNode)new Ques(exp);
			return res;
		};

    StarTerm = Term:exp STAR -> { return new Star(exp); };
    PlusTerm = Term:exp PLUS -> { return new Plus(exp); };
    QuesTerm = Term:exp QUES ~OPEN SP -> { return new Ques(exp); };

    Term = InputClass | ParenTerm | RuleCall | CallOrVar | Literal | AnyTerm;

    ParenTerm = OPEN Disjunction:exp CLOSE -> { return exp; };
    AnyTerm = PERIOD -> { return new Any(); };

    RuleCall = QualifiedId:name OPEN ParameterList?:p CLOSE -> { return new Call(name, p.Results); };
    ParameterList = Parameter (COMMA Parameter)* -> { return _IM_Result.Results.Where(node => node != null); };
    Parameter = CallOrVar | Literal;

    CallOrVar = ~KEYWORD QualifiedId:name -> { return new CallOrVar(name); };
    Literal = ((NEW GenericId? &'{') | &('\x22' | '\x27' | '{')) CSharpCode -> { return new Code(_IM_Result); };

    InputClass = '[' SP (ClassRange | &'\x27' Literal)+:c ']' SP -> { return new InputClass(c.Results); };
    ClassRange = &'\x27' Literal:from SP '-' SP &'\x27' Literal:to SP ->
        {
            char ch_from = AST.ClassRange.GetChar(from);
            char ch_to = AST.ClassRange.GetChar(to);

            List<char> range = new List<char>();
            if (ch_from > ch_to)			    
            {
                range.Add(ch_from);
                range.Add(ch_to);
            }
            else
            {
                for (char ch = ch_from ; ch <= ch_to; ++ch)
                    range.Add(ch);
            }

            return new ClassRange(_IM_Result, range);
        };

    CSharpCode = CSharpCodeItem:code SP -> { return new Code(code); };

    CSharpCodeItem = '{' (~'}' (Comment | CSharpCodeItem | EOL | .))* '}';
    CSharpCodeItem = '(' (~')' (Comment | CSharpCodeItem | EOL | .))* ')';
    CSharpCodeItem = '\x27' ("\x5c\x27" | "\x5c\x5c" | EOL | ~'\x27' .)* '\x27';   // '
    CSharpCodeItem = '\x22' ("\x5c\x22" | "\x5c\x5c" | EOL | ~'\x22' .)* '\x22';   // "
    
    Identifier = Ident:id SP -> { return id; };
    Ident = (IdentBegin IdentBody*):id -> { return new Idfr(id); };
    IdentBegin = '_' | . ?(System.Char.IsLetter(_IM_Result));
    IdentBody = '_' | . ?(System.Char.IsLetterOrDigit(_IM_Result));

	QualifiedId = (Ident (DOT Ident)*) SP -> { new Idfr(_IM_Result) };
    GenericId = (Ident (DOT Ident)*):ids SP (LESS (GenericId (COMMA GenericId)*) GREATER)?:gp
        -> { return new Idfr(ids, gp); };

	Number = ['0'-'9']+ SP;

	KEYWORD = USING | IRONMETA | OVERRIDE | NEW | LR;

    USING = "using" SP;
    IRONMETA = "ironmeta" SP;
    EQUALS = ('=' | "::=") SP;
    OVERRIDE = ("override" | "virtual" | "new") SP;
	NEW = "new" SP;
    LR = "lr" SP;
    SEMI = (';' | ',') SP;
    BANG = '!' SP;
    OR = '|' SP;
    ACTION = "->" SP;
    COLON = ':' SP;
    COMMA = ',' SP;
    DOT = '.';
    PERIOD = DOT SP;
    BRA = '{' SP;
    KET = '}' SP;
    OPEN = '(' SP;
    CLOSE = ')' SP;
    LESS = '<' SP;
    GREATER = '>' SP;
    QUES = '?'; // note no spacing
    AND_PRE = '&';
    NOT_PRE = '~';
    STAR = '*' SP;
    PLUS = '+' SP;
    
    EOL = ('\r' '\n'? | '\n') -> { _memo.Positions.Add(_IM_Result.StartIndex); return _IM_Result; };
    EOF = ~.;

    SP = (EOL | WS | Comment)*;
    WS = ' ' | '\t';
    
    Comment = "//" (~EOL .)* EOL;
    Comment = "/*" (~"*/" (EOL | .))* "*/";

}
